(()=>{const{Object:t,JSON:n,WeakMap:e,ReferenceError:r,TypeError:o,RangeError:i}=window,{keys:l,getOwnPropertyDescriptor:a}=t,{stringify:c,parse:u}=n,f=new e;function s(t,n){if(t instanceof Array&&"length"===n)return!0;let e=a(t,n);return!!e&&e.enumerable}function y(t,n){if(t===n)return!0;if("symbol"==typeof t&&"symbol"==typeof n)return t.description===n.description;let e=typeof t==typeof n,r=t instanceof Array==n instanceof Array,o=(t?t[Symbol.toStringTag]:null)===(n?n[Symbol.toStringTag]:null),i=e&&r&&o&&"object"==typeof t;return i&&t[Symbol.toStringTag]?.includes("Array")?t.length===n.length:i}function g(t,n,e=0){if(!t||!t.length)return n;var o=n,i=0;for(i=0;i<t.length-e;i++){let n=t[i];if(!s(o,n))throw new r("The given list does not point to any nested value in the given pointer");o=o[n]}return o}const h={__proto__:null,undefined:function(t){},Uint8Array:function(t){return new Uint8Array(t)},Uint8ClampedArray:function(t){return new Uint8ClampedArray(t)},Uint16Array:function(t){return new Uint16Array(t)},Uint32Array:function(t){return new Uint32Array(t)},BigUint64Array:function(t){return new BigUint64Array(t.split(","))},Int8Array:function(t){return new Int8Array(t)},Int16Array:function(t){return new Int16Array(t)},Int32Array:function(t){return new Int32Array(t)},Int64Array:function(t){return new Int64Array(t)},BigInt64Array:function(t){return new BigInt64Array(t.split(","))},BigInt:function(t){return BigInt(t)},Symbol:function(t){return Symbol(t)}};function p(t){const n=Array(t.length);for(let e=0;e<t.length;e++)n[e]=t[e];return n}function d(n,e){if(null==n)return e?n:null;let r=n[Symbol.toStringTag];if(r)return"Symbol"===r?e?Symbol(n.description):n.description:"BigInt"===r?e?n:n.toString():r.includes("Big")?e?h[r](p(n).join(",")):p(n).join(","):e?h[r](p(n)):p(n);if("object"!=typeof n)return n;let o=n instanceof Array?[]:{},i=t.keys(n);for(let t=0;t<i.length;t++){let e=n[i[t]];"bigint"!=typeof e&&void 0!==e&&(e&&(e[Symbol.toStringTag]||"object"==typeof e)||(o[i[t]]=e))}return o}function w(t,n,e,r,o,a,c,u){if(a>128)throw new i("Given object goes too many levels inward (>128)");let f=l(t),g=l(n),h=e.get(t);u&&c.set(t,!0),t instanceof Array&&(f.push("length"),g.push("length"));for(let e=0;e<g.length;e++)s(t,g[e])||(delete n[g[e]],r.push([[...o,g[e]]]));for(let i=0;i<f.length;i++){let l=f[i],u=t[l];if(s(n,l)&&u===n[l])continue;if("function"==typeof u){s(n,l)&&(delete n[l],r.push([[...o,l]]));continue}let g=[...o,l],p=h[1]<r.length&&o.length>=2?[h[1],l]:g,b=!y(t[l],n[l]),S=e.get(u),A=!s(n,l)||b;if(!A&&S&&(S[2]=0),A)if((b||void 0===u)&&(n[l]=S?S[3]:d(u,!0)),S){let[t,n,e]=S;e?t=n:(S[2]=2,S[1]=r.length),r.push([p,t,e])}else if(null==u||u[Symbol.toStringTag]){u&&"bigint"!=typeof u&&c.set(u,!0);let t=u||"bigint"==typeof u?u[Symbol.toStringTag]:"undefined";r.push([p,d(u),0,t])}else r.push([p,d(u)]);("symbol"==typeof u||"object"==typeof u&&null!==u)&&(S||e.set(u,[g,r.length-1,A?1:0,n[l],!1]),c.get(u)||(c.set(u,!0),w(t[l],n[l],e,r,g,a+1,c)))}}const b={__proto__:null,1:function(){return!1},2:function(t,n){if(1===t.length)return!1;try{return g(t[0],n),!1}catch{return!0}},3:function(){return!0}};let S=[];for(let t=0;t<256;t++)S[t]=String.fromCharCode(t);window.objToString=function(t,n){if(Array.isArray(t)||"object"!=typeof t||null===t)throw new o("root element of data MUST be an OBJECT");if(n)var r=d(t,!0);else var{clone:r,map:i}=f.get(t)||{};const l=[[[],i?{}:d(t)]],a=[],u=t&&t[Symbol.toStringTag]||null;if(h[u]&&l[0].push(0,u),!i){r=d(t,!0);var i=new e;f.set(t,{clone:r,map:i})}return i.set(t,[a,0,1,r]),w(t,r,i,l,a,1,new e,!0),c(l)},window.stringToObj=function(n,e,r=3){if(1===r||"1"===r)return e;let o="function"==typeof r?r:b[r];var i=u("string"==typeof n?n:function(t){let n=new Uint8Array(t),e="";for(let t=0;t<n.length;t++)e+=S[n[t]];return e}(n));"object"!=typeof e||null===e?e=2===i[0].length?d(i[0][1]):h[i[0][3]](i[0][1]):i[0][1]=t.assign(e,i[0][1]);for(let n=1;n<i.length;n++){let l=i[n],[a,c]=l[0];if("number"==typeof a&&(l[0]=[...i[a][0],c]),3!==r&&!o(l,e,i))continue;let[u,f,s]=l,p=u.at(-1);if(1===l.length)delete g(u,e,1)[p];else if(2===l.length){let n=g(u,e,1);y(n[p],l[1])&&"string"!=typeof l[1]?t.assign(n[p],l[1]):n[p]=l[1]}else if(3===l.length)g(u,e,1)[p]=g(s>0?i[f][s-1]:f,e);else{let t=g(u,e,1);y(t[p],l[1])||(t[p]=h[l[3]](l[1]))}}return e},window.objValueFrom=g,window.partFilter=function(t,n=!1){Array.isArray(t)||(t=[t]);for(let n=0;n<t.length;n++)if("string"!=typeof t[n])throw new o("manditoryPath MUST be an ARRAY of STRINGs");return"boolean"!=typeof n&&(n=Boolean(n)),function(e,r,o){if(e[0].length<=t.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[0][n])return!1;try{if(!n)return g(e[0],r),!1;if(3!==e.length)return!0}catch{if(3!==e.length)return!0}const i=o[e[1]][e[2]];if(i.length<=t.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==i[n])return!1;console.log({manditoryPath:t,referencePath:i});try{return!!n||(g(e[0],r),!1)}catch{return!0}}}})(),(()=>{var t=objToString({});WebSocket.prototype.on=WebSocket.prototype.addEventListener;let n=new Map,e=(t,n)=>crypto.getRandomValues(new Uint32Array(1))[0]%(t-n)+n;var r="abcdefgjiklmnopqrstuvwxyz-_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ :;.,\\/\"'?!(){}[]@<>=+*#$&`|~^%".split("");function o(t,o){"string"!=typeof o&&(o="webject_");do{var i="",l=e(2*t,t);for(let t=0;t<l;t++)i+=r[e(r.length-1,0)];i=o+i}while(n.has(i));return n.set(i,1),i}window.connect=async function n(e,r,i,l,a=!0){if("string"!=typeof e||"string"!=typeof r)throw new Error("BOTH location AND authToken MUST be STRINGS >:|");if(!0===a&&(a=t=>n(e,r,i,l,a)),"function"!=typeof a&&a)throw new Error("If you choose the optional parameter onFail, it must be a function >:|");if(l&&"object"==typeof l&&("function"!=typeof l.encoder||"function"!=typeof l.decoder))throw new TypeError("If coding parameter is used, it MUST be an object with both 'encoder' and 'decoder' functions");let c=null,u=null,f=null,s=null,y=!1,g=new WebSocket(e),h=new Promise(((t,n)=>(c=t,u=n)));function p(t,n){if(y)return null;let e=t,r=null;isNaN(e)&&(e=t.code),r=1006==e?"closed ABNORMALLY: either you or the server just LOST connection :|":1002==e?"authToken ENCODING FAULT: incorrect encoding/faulty protocol used, according to the server":1001==e?"authToken LOCKED: this is a correct key, but it takes no new connections 0_0":"closed PURPOSEFULLY: check your location and token parameters, OR you got BOOTED :/";let o=`connection with server is OVER due to event: ${n}\n${r}`;c?u(o):console.error(o),clearInterval(f),clearInterval(s),a&&(c?a().then(c):a())}return g.onerror=t=>{console.error("Attempting to connect to a websocket using the location parameter produced the following error :/\n~",t.message),a&&(c?a().then(c):a())},g.on("open",(async()=>{g.send(JSON.stringify(l?[r,await l.encoder(JSON.stringify([o(32,""),Date.now()]))]:r));let n=!1,e=Date.now();async function a(){let n=objToString(i);n!==t&&g.send(l?await l.encoder(n):n)}s=setInterval((function(){Date.now()-e>32768&&(y=!0,p(1006,"Connection Broken"))}),5e3),g.on("message",(async function(t){void 0!==t.data&&(t=t.data),"PING"==t&&(e=Date.now()),i=stringToObj(l?await l.decoder(t):t,i),n||(objToString(i),f=setInterval(a,20),n=!0,c(i))})),g.on("disconnect",(t=>p(t,"disconnect"))),g.on("close",(t=>p(t,"close"))),g.on("error",(t=>p(t,"error")))})),await h}})();